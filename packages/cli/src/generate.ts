import fs from "fs-extra";
import path from "path";
import { ColumnType, Schema } from "@worksonmydb/core";
import { getSchema, WorksOnMyDbConfig } from "./config";

export async function generateModels(config: WorksOnMyDbConfig): Promise<void> {
  const schema = getSchema(config);
  const baseDir = process.env.INIT_CWD || process.cwd();
  const modelsDir = path.resolve(baseDir, config.modelsDir ?? path.join("packages", "models", "src"));
  await fs.ensureDir(modelsDir);

  const typesPath = path.join(modelsDir, "types.ts");
  const validatorsPath = path.join(modelsDir, "validators.ts");

  await fs.writeFile(typesPath, buildTypesFile(schema), "utf8");

  if (await isZodAvailable()) {
    await fs.writeFile(validatorsPath, buildValidatorsFile(schema), "utf8");
  } else {
    await fs.writeFile(validatorsPath, buildValidatorPlaceholder(), "utf8");
  }
}

function buildTypesFile(schema: Schema): string {
  const lines: string[] = [];
  lines.push("// Generated by WorksOnMyDB. Edit your schema file instead of this output.");
  lines.push("");

  for (const table of schema.tables) {
    lines.push(`export interface ${toPascal(table.name)} {`);
    for (const column of table.columns) {
      lines.push(`  ${column.name}${column.notNull ? "" : "?"}: ${columnTsType(column.type)};`);
    }
    lines.push("}");
    lines.push("");
  }

  lines.push("export interface Tables {");
  for (const table of schema.tables) {
    lines.push(`  ${table.name}: ${toPascal(table.name)};`);
  }
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

function buildValidatorsFile(schema: Schema): string {
  const lines: string[] = [];
  lines.push("// Generated by WorksOnMyDB. Requires `zod` to be installed.");
  lines.push('import { z } from "zod";');
  lines.push("");

  for (const table of schema.tables) {
    lines.push(`export const ${table.name}Validator = z.object({`);
    for (const column of table.columns) {
      const validator = columnZodType(column.type, column.notNull === true);
      lines.push(`  ${column.name}: ${validator},`);
    }
    lines.push("});");
    lines.push("");
  }

  lines.push("export const validators = {");
  for (const table of schema.tables) {
    lines.push(`  ${table.name}: ${table.name}Validator,`);
  }
  lines.push("};");
  lines.push("");

  return lines.join("\n");
}

function buildValidatorPlaceholder(): string {
  return [
    "// zod not installed. Install `zod` to generate validators automatically.",
    "export const validators: Record<string, unknown> = {};",
    ""
  ].join("\n");
}

function columnTsType(type: ColumnType): string {
  switch (type.kind) {
    case "int":
      return "number";
    case "bool":
      return "boolean";
    case "datetime":
      return "Date | string";
    case "json":
      return "unknown";
    case "text":
    case "varchar":
    default:
      return "string";
  }
}

function columnZodType(type: ColumnType, required: boolean): string {
  let base = "z.any()";
  switch (type.kind) {
    case "int":
      base = "z.number().int()";
      break;
    case "bool":
      base = "z.boolean()";
      break;
    case "datetime":
      base = "z.coerce.date()";
      break;
    case "json":
      base = "z.any()";
      break;
    case "text":
    case "varchar":
    default:
      base = "z.string()";
      break;
  }
  return required ? base : `${base}.optional()`;
}

async function isZodAvailable(): Promise<boolean> {
  try {
    require.resolve("zod", { paths: [process.cwd()] });
    return true;
  } catch {
    return false;
  }
}

function toPascal(value: string): string {
  return value
    .split(/[_\s-]+/)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join("");
}
